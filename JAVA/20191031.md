# JAVA

[ 20191028 ]
    

```java
<SCSA - JAVA과정>
 이길재
 jaelee1004@naver.com
 010-2787-1825

<공유>
1. 강의장
  \\70.12.60.50
  ---> 공유폴더 : jaelee

2. 구글드라이브
https://drive.google.com/open?id=12htYkos3x2B5R0fRIAohRtpaQQBctxe_

<환경변수설정>
- JDK 인스톨후 PC가 JDK의 위치를 인식하게 한다.
- JDK위치설정(bin, lib)

1. 자바경로
   ---> 제어판
         ---> 시스템 환경변수 편집
         ---> 고급탭
         ---> 환경변수 버튼 클릭

   변수이름:  JAVA_HOME
   변수값: C:\Program Files\Java\jdk1.8.0_221

2. path 경로추가 (자바 관련 명령어들의 위치 설정)
   %JAVA_HOME%\bin;
   
3. classpath 경로추가 (새로 추가될 클래스 파일들의 위치 설정, 생략가능)
   .;%JAVA_HOME%\lib;

<설정확인법>

※ 주의: 위의 설정이 끝난후 cmd창을 새롭게 열어서 확인하여야 함.

1. cmd(command)창열기

2. C:\Users\student>javac -version
    javac 1.8.0_221

3. C:\Users\student>java -version
    java version "1.8.0_221"

====================================================================

<프로그램 작성>
1. 메모장 열기 
    - 좌측하단 윈도우 버튼에서 notepad 입력

2. 프로그램 작성 
소스코드(HelloTest.java) 작성
     ----> 사람이 읽을 수 있는 파일을 Source File이라고 함.

 public class HelloTest
 {
    public static void main(String args[])
     {
        System.out.println("안녕, 자바~!!");
     }
 }

     ===> 저장파일명은 반드시 첫줄의 class 뒤에 있는 단어와 일치!!
          (대소문자까지)
     ===> HelloTest.java (O)
              helloTest.java (X)
              Hellotest.java (X)

 컴파일) 
   HelloTest.java   ------Compile(javac.exe)------->  HelloTest.class
 
 명령어 실행)
   javac 컴파일하고자 하는 자바파일명(.java확장자 포함)
   ----> javac HelloTest.java	(.java는 사람들이 읽을 수 있는 파일, .class는 컴퓨터가 읽을 수 있는 파일이라
고 생각하면 됨!!)
   ----> HelloTest.class 파일 생성
   ----> 다시 java HelloTest 명령어 치면, public static void main의 내용 실행!(밑에 있는 3. 번)

3. 바이트코드(HelloTest.class)실행
  ---> Source File은 자바JVM(자바가상머신)이 읽을 수 없으므로
      반드시 컴파일 과정을 거쳐 ByteCode File로 변환시켜야 함.

 인터프리터) 
   HelloTest.class   ------Interpreter(java.exe)------->  JVM위에서 실행
 명령어 실행)
   java 실행하고자 하는 자바파일명(.class확장자 포함하지 않음!!)
   ----> java HelloTest
```


​	    

    ==========================================================================
    이클립스  ==> IDE (통합개발환경)
                ==> 이클립스는 Plug-in개념 , 추가 플러그인을 설치하면 여러환경을 현재 이클립스에서 실행할 수 있
    음
                ==> 이클립스 버전이 높을 수록 추가된 기본 플러그인이 많음.
                ==> (프로그램작성)에디터내에서 여러환경을 이동없이 실행할 수 있음
                                        ------
                                        실행결과창, 웹브라우저, DB서버시작 정지, Web서버시작 정지 ,협업 정보 등
                
    http://www.eclipse.org
    ---> eclipse-jee-2019-03-R-win32-x86_64.zip 다운받기
    ---> C: 또는 D: 또는 E:드라이브 아래 압축풀기
    ---> eclipse/eclipse.exe 실행!!
    
     < 이클립스 단축키 > 
     ==> 메뉴 Window - Preferences - General - Keys   : 이클립스에 지정된 여러 키정보를 확인할 수 있음.
     ==> 유용한 기본 키     
         ctrl + space           : 자동 완성 기능
         ctrl + 1               : 제안 기능
         
         ctrl + /               : 한줄 주석 추가, 제거
         ctrl + alt + 아래화살표     : 선택된 블럭을 복사하여 아래쪽으로 붙여넣기
         alt  + 위아래화살표              : 선택된 블럭을 위아래로 이동
         
         ctrl+shift + 더하기 기호    : 글자크기 늘리기
         ctrl+shift + 빼기 기호       : 글자크기 줄이기


​    
​    

```java
==========================================================================

※(JAVA)프로그램을 잘 하려면?
1. 프로그램의 구성요소를 잘 알아야 함.
   - 필드(Field; C에서의 변수라고 생각.) : 데이터 속성, 자료구조, 데이터를 담는 그릇

   - 메소드(Method; C에서의 함수라고 생각. 기능정의 부분.) : 기능, 행위

   - 클래스(Class) : 자바 프로그램의 기본 단위(파일 단위)
		     필드와 메소드를 담는 울타리(Template)

	=> 클래스와 메소드는 독립적으로 존재할 수 없음

2. 구성요소의 구분
   - 필드(변수)	: 첫 글자 소문자 ( 단어 뒤에 ()소괄호 X )

   - 메소드	: 첫 글자 소문자 ( 단어 뒤에 ()소괄호 O )

   - 클래스	: 첫 글자 대문자 원칙!! -- 하지만 이런 문법 지키지 않는다고 에러가 뜨는 것은 아님...

		System.out.println("안녕");
	      [클래스][필드][메소드] 순임!
		--------------------------------------------------------------------
		원칙을 지키지 않아도 에러는 발생하지 않음!
		--> 단지 가독성이 떨어질 뿐!

3. 구성요소의 형식
   - 필드(변수)	: [자료형] [변수명];

     변수가 한 번 어떠한 자료형으로 선언이 되었다면, 다른 타입을 절대 담을 수 없다 에러난다!

	ex>   커피 v1;   -->  v1이라는 그릇에는 커피"만" 담을 것이다!!
	      물 v2;
	    ㆍint su;    -->  su라는 변수(그릇)에는 정수 데이터"만" 담을 것이다. <변수 선언>
	    ㆍsu = 100;  -->  su 변수에 100이라는 정수 저장! <변수 초기화, 값 할당>

   - JAVA의 자료형 : 8개(byte, short, int, long, float, double char, boolean) - 기본 자료형 : 소문자로 사용
		    + 알파(String, ...) - 클래스 자료형 : String의 경우, 클래스 자료형임에도 기본 자료형처럼 
사용!
	ㆍ숫자
		정수
			byte	: 1B만큼 담음	-128 ~ 0 ~ 127	---> ASCII 코드 표현할 때 주로 사용
			short	: 2B	〃
				int	: 4B	〃	---> 제일 많이 사용
			long	: 8B	〃
		실수 
			float	: 4B	〃
			double	: 8B	〃	---> 제일 많이 사용

	ㆍ문자
			char	: char ch;	ch = 'a'; or ch = '홍';

			.......
			System.out.println(a);		-- a라는 변수. a가 현재 담고 있는 값을 출력.
			System.out.println('a');	-- a라는 '문자' 출력.
			System.out.println("a");	-- a라는 "문자열" 출력.
			.......			     (뒤의 둘은 결과 같아 보이지만, 엄연히 데이터 타입이 다
름!(문자 한 개만 담을 수 있냐, 여러 개 담을 수 있냐 차이) 하지만 중요한 것은, 따옴표 사용하는 이유가 변수와 
문자(열)을 구분하기 위함!)

	ㆍ논리(boolean)
			boolean	: boolean b1 = true;
				  boolean b2 = false;	-- 참, 거짓만 저장 가능!

				  boolean eb1 = 1;
				  boolean eb2 = 0;	-- 에러 뜸!! 숫자로 표현 불가능!
```


​    

```java
	ㆍ문자열
			String	: "S"만 첫 글자가 대문자이다!!! 첫 글자가 대문자인 것은 클래스로 간주!
				: String str;	str = "홍길동";
				  String str2 = "고길동";	-- 변수 선언과 초기화 함께 해줘도 됨!
				  String str3 = "";		-- 빈 문자도 가능
				  String str4 = "g";		-- 한 개의 문자도 가능
```


​    

```java
	★★메소드 형식★★
	
	ㆍ표현 방법

	  [return 자료형] [메소드명] ( 매개변수 )
	  { // 메소드의 시작

	  } // 메소드의 끝 (중괄호 : 프로그램 내에서 영역/scope 표현)

	ㆍ리턴자료형	: 메소드를 실행하고 난 후의 결과 데이터 표현 (return data type)
	  리턴 자료형에 위치할 수 있는 단어?	: 자료형!!! (8개 기본 자료형!! + Class 자료형!! + void)

	ㆍ매개변수	: 메소드 실행에 필요한 데이터를 외부에서 전달 받는 것을 표현
			  parameter, argument, 인수, 인자

	ㆍ실행순서	: 매개변수 -(메소드 내로 들어가서)-> 메소드 내의 내용들 수행 -(그 결과값을)-> 리턴

	★클래스 형식★

	※ 공백(White Space)의 정의 : 한 개 이상의 space 또는 tab, 또는 Enter의 조합을 말함!

	ㆍ표현 방법

	  class [클래스명]
	  { // 클래스 시작

		변수 선언	: 클래스 멤버 변수

		메소드를 정의(define)하고 구현함!

	  } // 클래스 끝

	ㆍ변수 선언
		- 변수 선언하고, 따로 초기화하는 것는 불가능...;; 그냥 선언만!!
		  선언과 동시에 초기화하는 것은 가능!!
		- 같은 클래스 내 똑같은 변수명 두 번 이상 선언 못 함!)
	※ 클래스 멤버변수(클래스 내 메소드와 동일한 level로 선언된 변수 => 클래스 내 모든 메소드가 공유!!)
	   , 지역변수(메소드 매개 변수, 메소드 내에서 선언된 변수 포함)

	ㆍ메소드 정의 및 구현
		- 리턴타입, 메소드명, 매개변수(변수 선언!!), 메소드 구현 내용 있으면 Good!!
		- 내부 : 
			변수 선언, 초기화 : 선언하면서 초기화도 가능!
			메소드 호출	: 가장 많이 사용됨!	ex. getValue(a);, System.out.println
			조건문		: if( . . . . . ) {  }, switch
			반복문		: for, while, do ~ while
			제어문		: 반복문, switch문 등 내부에서 break, continue;
```


​    	

```java
4. 구성요소의 사용법
   - 필드(변수)	: 자료형 선언된 변수에 데이터를 초기화!

   - 메소드	: 메소드 호출(메소드명 호출)

   - 클래스	: ★객체를 생성★하여 사용!	== 메모리 할당
```


​    

```java
	ㆍ객체생성식 : A클래스의 객체를 생성한다는 것은, new라는 객체 생성 키워드를 이용하여 
		      A라는 울타리 내 에 있는 변수, 메소드들을 사용하기 위해 선언하는 것이다!!!!★

	  A  OBJ  =  new              A  (  ) ;
	---  ---     ---             ---
   클래스명  변수명  객체생성키워드  클래스명
		- 변수명 : 객체의 주소가 담겨 있음. 이 주소로 접근하여 메소드, 변수 이용 가능!!!★

	ex.
		class My {
			int su = 300;
			void hello() {
				System.out.println("안녕하세요~!");
			}
		}

		==> 위의 프로그램을 사용하기 위해 객체 생성을 한다!!
		    실제 사용하는 것은 내부에 있는 변수 su와 메소드 hello()!!!!

			==> 객체 생성식	:	My my = new My();
					★My 클래스가 포함한 멤버들에 대한 메모리를 할당하는 것!★

					my는 메모리 참조하는 변수(Reference 변수!)
					--> [기본자료형] [변수명];	: 속성변수
					    [클래스자료형] [변수명];	: 참조변수! 즉, ★주소★ 담는 변수!

		==> 사용법> [참조변수명].[필드명]
		            [참조변수명].[메소드명]();

   - 하나의 JAVA 파일 내에 두 개 이상의 클래스를 정의하는 것이 가능하다!
     But, 권장하지 않는다! 별도의 클래스 파일을 만들어서 사용하는 것이 가독성 좋음.
   - 클래스의 최소 구성 요소 수는 3개,	-- class, 클래스명, { }  ('public'을 지워서 저장해도 에러가 뜨지 않
음!)
     메소드의 최소 구성 요소의 수는 4개 -- 리턴타입, 메소드명, 매개변수, { }
```


​    
​    
​    

```java
==========================================================================

※식별자(identifier) 이름 규칙	: 변수명, 메소드명, 클래스명, 패키지(폴더 개념)명에 적용

1. 식별자명	: 보통 영문자, 숫자로 조합
2. 특수문자 사용 불가 (단,  "_"와 "$" 는 예외적으로 사용 가능!)
   String studentname = "홍길동";
   String studentName = "홍길동";	-- Camel style
   String student_name = "홍길동";
   String student$name = "홍길동";	-- 얘처럼 사용할 수도 있음, But 권장하지 않음!
					   내부 클래스에 예약이 되어 있으므로 사용을 권장하지 않음!
3. 첫 글자 숫자 불가
4. 한글 사용 가능	-- JAVA는 유니코드(16bit) 지원하기 때문
   But 권장하지 않음! 가독성이 떨어지기 때문.
```


​    

```java
[ 20191029 ]

< Review >
1. 필드 / 변수 (완전 같지는 않음)
	- 데이터의 속성
	- 자료구조
	- 데이터를 담는 그릇
	- 표현 : [자료형] [변수명];  ( 추가적으로 선언과 동시에 초기화 가능 )
		▶ 자료형 : 기본자료형 8개(문자 1, 정수 4, 실수 2, 논리 1)
							+ 알파(클래스 자료형 ex. String, System 등)

2. 메소드 / 함수
	- 기능, 행위
	- ★표현 : [return자료형] [메소드명] ( [매개변수] )
			  		 {
				   			▶ 메소드 정의 및 구현
				   	 }
			▶ return자료형 : 기본 자료형, 클래스 자료형, void
			▶ 매개변수 : 인수, 인자, 파라미터, 아규먼트라고도 함
	- 

3. 클래스
	- 필드와 메소드는 독립적으로 존재할 수 없다. 클래스가 있어야만 한다!
	- JAVA 프로그램 기본 단위(파일)
	- 필드와 메소드를 담는 울타리(Template)
	- 클래스 외부에 변수/필드를 선언할 수 없음
		1                  -> 불가
 		class My   2       -> 불가. 상속 관련
		{
				3                  -> 멤버변수
				void speedUp( 4 )  -> 지역변수
				{
						5              -> 지역변수
				}
				6                  -> 멤버변수. 전혀 문제 없지만, 가독성이 떨어지므로 권장하지 않음
		}
		7                  -> 불가

		▶ 클래스 내, 필드선언 - 생성자 정의 - 기능 메소드의 순서로 선언 및 정의, 구현해줌!
```


​    

```java
	- ★표현 : [class] [클래스명] {  }
	- A a = new A();와 같은 표현으로 선언 및 동적메모리 할당
		▶ ★메모리에 클래스 내의 필드와 메소드를 위한 메모리가 할당이 되고,
			a 변수는 이 클래스의 참조 변수로서 클래스의 주소값을 갖게 됨!
(클래스 관련..)
4. static은 클래스가 아닌 메소드와 필드에 붙일 수 있음
	- static이 붙어 선언됐다면, Runtime시에 바로 메모리가 할당이 되므로,
		new를 이용하여 동적메모리를 할당할 필요가 없음

=============================================================================
```


​    

```java
● 패키지
	- **서로 관련이 있는 클래스들의 묶음**
	- namespace(이름 공간)의 개념.
	- **이름 충돌 방지 :** 같은 패키지 안에 역시 같은 이름의 클래스 만들지 못함!
			▶ 클래스 파일 내에서 package com.scsa.j2019.pack1;로 써주면, 에러가 떠버림
					-> 에러 메세지에서 'move'를 선택하게 되면 자동적으로 새로운 패키지 생성됨!ㅋ
	- **JVM이 인식하는 폴더**
	- JAVA에서는 2개 이상의 패키지명을 사용하는 것을 권장
	- 현재 클래스의 위치를 표현

	- import는 **외부에서 가져오는 클래스를 사용**하고자 할 때!
		▶ import [패키지명].[클래스명];
			또는 import [패키지명].*;    로 사용
									( *(와일드카드) : (ex.)pack1 패키지 밑의 모든 클래스를 현 클래스에서 사용하겠다는 의미 )
									( 하지만 클래스 이름을 명시적으로 사용하는 것을 권장 )
	- 또 다른 예시
		Calendar cal;   // Calendar 클래스가 현재 클래스에서 정의되어 있지 않기에 에러가 뜨는 것!
		위로 가서 import java.util.Calendar; 이라고 선언해주면 됨!
	- 컴파일러가 자동적으로 import를 추가해주는 것이 있는데....
		▶ 바로 import java.lang.String;    import java.lang.System; 등의 것
			JAVA 컴파일러가 컴파일 시, import java.lang.*;  이라고 **자동으로 추가**해줌!
			( **java.lang은 기본 패키지임!** )
		▶ 그럼 위의 Calendar은 왜 에러가 뜬 거임? : 기본 패키지인 java.lang에 포함되는 것이 아니었음!

	- 보통 JAVA는 두 명 이상이 함께 작업하는 경우가 많은데.
		아무래도 같은 이름의 클래스나 프로젝트명에 의해 에러가 뜨는 경우가 많아..
	- 그래서 (ex.) 회사 구분을 위해 패키지라는 것을 만들어 관리
	- samsung.co.kr이 회사의 도메인이라면,
		kr.co.samsung과 같이 역순으로 이름을 지어줌
		( 패키지명도 필드, 메소드, 클래스명의 원칙과 동일함 
			So 숫자만으로 붙일 수 없음! )
		▶ 수업시간에는 com.scsa.***j1029***와 같이 사용
		▶ workspace가서 폴더/파일 보게 되면, (상위 -> 하위 순) src >> com >> scsa >> j1029
```


​    

```java
● import
	- 현재 클래스에서 사용할 외부 클래스의 위치를 표현
		▶ 표현 : import [상위패키지명].[하위패키지명]. ... .클래스명;
			ex. import java.util.Calendar;
					import java.io.BufferedReader;

		▶ 예외 : java.lang에 있는 클래스와
							현재 클래스와 동일한 패키지에 있는 클래스는 import 해줄 필요가 없음

		▶ 다른 방법 : import 안 해도 되지만, 번거로움. 하지만 필요한 경우도 있음!
			class A {
					void hello() {
								java.util.Calendar c = new java.util.Calendar();
					}
			}

● Comment / 주석문
	- 프로그램에 대한 설명
1. 라인 주석문 : //
2. 블럭 주석문 : /*   */

========================================================================

● JAVA 연산자

1. 산술 연산자 : + - * / %
	- + : 숫자를 더하는 기능뿐만 아니라, **문자열을 붙여주는 역할도**!!
		▶  System.out.println("안녕"+10+20);
	    	// "안녕10"+20 					= "안녕1020" 으로 인식
	    	System.out.println(10+20+"안녕");
	    	// 10 + 20 + "안녕" = 30 + "안녕" = "30안녕"으로 인식
		▶ System.out.println("no1 - no2 = " + no1 - no2);
				라고 작성을 한다면, no1 - no2의 연산 결과가 아니라, 에러가 뜸!!
				'-'는 문자열을 빼주는 역할을 하지 못 하는데,
				"문자열" - 숫자 형태가 되기 때문!!!
    
2. 증감 연산자 : ++, --, 전치, 후치
	- 

3. 비교 연산자 : <, >, <=, >=, ==, !=
	- **비교연산자의 결과는 boolean 값을 가짐!!!**

4. 논리 연산자 : &&, ||
	- **논리연산자의 결과는 boolean 값을 가짐!!!**

==================================================================

● Switch ( [기준데이터] )
	{
		case [비교데이터1]:
					실행할 문장;
					break;
		.
		.
		.
		default:
					break;
	}
	▶ 기준데이터가 long이 아닌 정수, 문자, 그리고 String이 가능!
	▶ if, while 문 안에 들어가는 조건문은 결국 boolean 타입!

=============================================================================

< 예제 >

package com.scsa.mission1029;

public class Mission1 {
	public static void main(String[] args) {
		for(int i = 1; i <= 5; i++)
		{
			System.out.println(i);
		}
		
		for(int i = 5; i >= 1; i--)
		{
			System.out.print(i + " ");
		}
		
		for(int i = 3; i <= 9; i += 3)
		{
			System.out.print(i + " ");
		}
		System.out.println();
		
		System.out.print("[");
		for(int i = 5; i <= 20; i += 5)
		{
			if(i == 20) System.out.println(i + "]");
			else System.out.print(i + ",");
		}
		
		int Fibo[] = new int[30];
		Fibo[0] = Fibo[1] = 1;
		for(int i = 2; i < 30; i++)
		{
			Fibo[i] = Fibo[i - 2] + Fibo[i - 1];
		}
		for(int i = 0; i < 30; i++)	System.out.print(Fibo[i] + " ");
	}
}

============================================================================

● System.out.println(       );
	- out은 필드 ( 괄호가 없으니까 ) && System클래스의 필드
	- println은 메소드 && 그럼 얘도 System 클래스의 멤버 메소드이냐? NOPE!!
		**out**은 System 클래스의 필드변수이기는 한데, 얘의 **타입은 PrintStream이라는 클래스 타입!**
		그러므로 println은 out의 멤버 메소드!! 즉, 또 다른 클래스의 메소드임!

● System.in.read(  );
	- 키 값 하나만 입력받을 수 있음!
		( 버퍼에 Enter가 있다면, 버퍼에는 **원래 입력하려던 값**뿐만 아니라, **개행**과 **캐리지리턴**이 입력될 것 )
		( 개행은 13, 캐리지리턴은 10의 아스키값을 가짐!
			하지만 그 다음에 있던 System.in.read도 한 자만 받을 수 있기에 캐리지리턴은 **씹힘** ㅋ )
	- **return**값이 우리가 키보드로 입력한 값에 대한 **아스키코드 값**

	- **바이트 단위 입력**
		// 정수를 입력 받는 방법!	
		// 1)
		char input2 = (char)System.in.read();
		// return값이 우리가 키보드로 입력한 값에 대한 아스키코드 값
		System.out.println(input2);	// 문자를 출력
		System.in.read();
		System.in.read();			// 개행과 캐리지리턴을 처리해주기 위함!
		// 2)
		int input = System.in.read() - 48;
		System.out.println("input : " + input); // 아스키코드 값 - 48은 정수 값
		System.in.read();
		System.in.read();			// 개행과 캐리지리턴을 처리해주기 위함!
```


​    

```java
	( import java.io.BufferedReader; 필요!! - Ctrl + Spacebar 누르면 자동적으로 나옴 )
	- **라인 단위 입력**
		// 문자열 입력 받기!
		// 라인 단위 입력 (개행 전까지!)	=>	BufferedReader 클래스 - readLine() 메소드
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
							// a메소드 호출( b메소드 호출( c메소드 호출 ) )  -> 이런 구조임!
							// 처리 순서는 c의 결과를 얻어 -> b의 결과를 얻어 -> a의 결과를 얻음
							// c : 키보드 바이트 입력
							// b : 바이트를 모아 모아 모아서 Reader로 변환
							// a : 버퍼에 모아서 처리
							// ( 한 자 한 자 처리하는 것보다 버퍼에 모아서 처리하는 것이 더욱 빠름!! )
		String str = br.readLine();

					▶ JAVA에서는 특히 입력에서 "예외처리"를 강제함.
						 br.readLine()을 사용하기 위해서 아래와 같이 예외처리해줌!
							▷ public static void main(String[] args) **throws IOException {**
					▶ 예외처리 (크게 두 가지)
							▷ try / catch          -- 수업시간에는 다루지 않을 것임!
							▷ throws IOExection    -- 예외 발생해도 내가 처리하지 않고 다른 사람에게 위임!

			System.out.println(str);
						// 라인 입력을 받은 값이 나옴 (But, String타입임!)
```


​    

```java
			System.out.println(str + 100);
						// (123을 입력했다면,) 123100이 출력됨!
		
			int su = Integer.parseInt(str);
			System.out.println(su + 100);
						// 위의 출력과 결과가 다르게 나옴! => su는 정수 100이기 때문에 => 223이 출력됨!

==========================================================================

< 나이 구하기 >

package com.scsa.mission1029;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Calendar;

public class GetAgeTest {
	public static void main(String[] args) throws IOException {
		// 콘솔을 통해 주민번호를 입력 받고, 그에 해당되는 나이를 화면에 출력!
		
		// 날짜 관련 클래스 ( 현재 시기 알아오기 위해서! ) : 대표적으로 Date, Calendar
		//     - Calendar은 abstract로 class 선언이 되어 있음. 이 추상클래스는 new 사용 불가!!
	
		Calendar cal = Calendar.getInstance();	              // 연월일시분초 정보가 다 들어감 오오오오오!!
		int cur_year = cal.get(Calendar.YEAR);		            // 오늘의 YEAR을 받아옴!
		//System.out.println(cal.get(Calendar.YEAR));
		
		for(;;)
		{
			System.out.print("당신의 주민등록번호를 입력해주세요 (-으로 구분해주세요) : ");
			BufferedReader input_idno = new BufferedReader(new InputStreamReader(System.in));
			String idno = input_idno.readLine();
			if( idno.charAt(6) != '-' || idno.length() > 14 )
			{
				System.out.println("잘못 입력하셨습니다. 다시 입력해주세요!");
				continue;
			}

			char check = idno.charAt(7);	      // 0 ~ 배열이라고 생각하고, 8번째 요소 받아옴
																					//  .substring(0, 5) : 0 ~ 4요소까지 받아옴
																					//   ( 시작 요소 포함, 끝 요소 불포함!!!! )
			int thou = (check < '3') ? 1900 : 2000;	
			int year_last2 = Integer.parseInt(idno.substring(0, 2));
																					// Integer.parseInt(  ) 괄호 내의 문자열을 숫자로 바꿔줌
			int yourage = cur_year - (thou + year_last2) + 1;
			
			System.out.println("당신의 한국 나이는 " + yourage + "세입니다.");
			break;
		}
	}
}
```


​    

```java
==========================================================================

< 하루 마무리 미션 >

1. 현재 Time 구하기

import java.util.Calendar;

public class PrintCurTime {
	public static void main(String[] args) {
		char Yoil[] = { '일', '월', '화', '수', '목', '금', '토' };
		
		Calendar cal = Calendar.getInstance();
		System.out.println(cal.get(Calendar.YEAR) + "년 "
						+ (cal.get(Calendar.MONTH) + 1) + "월 "
						+ cal.get(Calendar.DATE) + "일 " 
						+ cal.get(Calendar.HOUR_OF_DAY) + "시 "
						+ cal.get(Calendar.MINUTE) + "분 " 
						+ cal.get(Calendar.SECOND) + "초 "
						+ "(" + Yoil[cal.get(Calendar.DAY_OF_WEEK)] + "요일)");
	}
	
	// cal.get(Calendar.MONTH)의 값 : 1월이 0에서부터 시작하므로, 10월은 9일 것. 그래서 +1을 해줘야 잘 나옴!
	// cal.get(Calendar.HOUR)은 오전, 오후가 구분된 값이므로 (12시간 기준)
	// cal.get(Calendar.HOUR_OF_DAY)을 이용하면 16시가 찍힘 (24시간 기준)
}
```


​    

```javascript
2. 별 찍기

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class PrintStar {
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(in.readLine());
		
		for(int i = 1; i <= N; i++) {
			for(int j = 1; j <= i; j++)	{
				System.out.print("*");
			}
			System.out.println();
		}
	}
}

/*
 * 		백준 제출 코드
  		import java.io.BufferedReader;
			import java.io.IOException;
			import java.io.InputStreamReader;
			
			public class Main {
				public static void main(String[] args) throws NumberFormatException, IOException {
					BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
					int N = Integer.parseInt(in.readLine());
					
					for(int i = 1; i <= N; i++) {
						for(int j = 1; j <= i; j++)	{
							System.out.print("*");
						}
						System.out.println();
					}
				}
			}
 
*/
```


​    

```java
[ 20191030 ]

● JAVA I/O : 4대 Class가 있음
		< B단위 >
	- InputStream   : 
	- OutputStream  : 

		<문자 단위>
	- Reader        : 
	- Writer        : 

		▶ InputStream + Reader = InputStreaReader : 키보드로 한 바이트 단위로 읽어 문자로 연결

===============================================================================

**< ※ 객체지향 (OOP : Object Oriented Programming) ※ >** : 재사용성 특히 중요

★
1. **캡슐화**

	● **연관된 데이터와 함수를 논리적으로 묶어**놓은 것이며, 
		데이터를 보호하기 위해 **다른 객체의 접근을 제한**하는 **접근 제한 수식자의 기능**을 제공
			▶ 쉽게 말하면, 클래스의 필드와 메소드를 묶어주는 것! : **모듈성**
			▶ **정보의 은닉** 가능!

	● 캡슐화를 함으로써 **데이터의 손상과 오류 발생을 최소화**시킬 수 있으며, 
		객체 조작 방법이나 데이터가 변경되어도 사용방법은 변경되지 않아
		**다른 객체에 영향을 끼치지 않음**. 
			▶ **독립성**이 유지
			▶ 객체간의 결합도가 낮아져 인터페이스가 간단해짐
			▶ 사용자는 데이터가 처리된 결과만을 사용하기 때문에 **객체의 이식성**이 뛰어남
```


​    	

```java
★★★
2. **상속**
			- 우리가 어제 봤던 java.lang.Object 밑의 java.util.Calendar
											 (부모 클래스/Super)      (자식 클래스/Sub)
 (Object 클래스는 JAVA 모든 클래스의 부모 클래스이자 최상위 클래스!!)

	● **자식은 부모 클래스로부터 상속받은 모든 것을 사용할 수 있**지만.
		**반대로** 부모 클래스는 자식 클래스의 것을 사용할 수 없다!
		추가적으로 부모의 클래스도 다른 클래스의 자식 클래스라면,
		**자식 클래스는 조부모 클래스의 것들도 사용할 수 있**다

	● 이해를 위한 예시 : 키워드 **extends (상속 받고자 하는 클래스 하나만 써야 함!! 단일상속 원칙!)**
																		( **자식은 부모**다! 의 의미를 갖게 됨 )

[자식 클래스 선언] [extends] [부모 클래스 이름]	
	class Child **extends Parent** {
			
	}

					(상 **▲** 속)

	class Parent {
			int su = 300;
			void hello() {
					System.out.println("Hello~");
			}
	}
			▶ 이렇게 상속이 되었다면.
				Child c = new Child();
				c.hello();
				System.out.println(c.su);
				이렇게 **부모의 필드와 메소드를 사용 가능!**!!
			▶ Parent 클래스는 extends를 써주지 않았으므로 상속을 받지 않았다.
				하지만 자식클래스 객체 c에서 c.toString();을 해보면 사용이 가능하다는 것을 알 수 있다.
				(toString은 Object 클래스의 메소드!!)
				JAVA에서는 자동적으로 extends Object가 추가되어 이런(?) 클래스들을 기본적으로 상속 받을 수 있게 한다!!
			▶ 
				Child c2 = new Parent();    --> 에러 뜸!
																				**r-value만 봐보자! 부모가 자삭이 될 수 있는가? 없다!**

				Parent p2 = new Child();    --> 에러 뜨지 않음!
																				선언을 부모로 하고, 자식을 상속 받는다면 실행 가능!
																				**r-value만 봐보자! 자식이 부모가 될 수 있는가? 있다!**	
★★★
3. **다형성 (**형태가 많다**)**

	● **메소드 오버로딩**(Overloading)
		- **동일한 클래스 내**에 "**같은 이름"을 가진 메소드**를 **여러 개** 구현 (**상속과 관련 X**)
		- 단, "**매개변수"의 개수, 자료형 타입이 다르**다면!!! (리턴타입 노 상관)

		★★
	● **메소드 오버라이딩**(Overriding) : 상속에서 나온 개념!
		- 상속 관계가 있을 때, 
			자식 클래스가 부모 클래스로부터 물려 받은 메소드를 변경하여 사용할 수 있다!
			그대로 사용을 하더라도, 더 필요한 부분을 추가하여 사용할 수 있다!
			( 즉, 부모가 물려준 메소드의 내용을 조금이라도 변경하면 오버라이딩이다! )
				▶ **메소드 재정의** (부모로부터 물려 받은 메소드에 대한)

		- 메소드의 이름, 리턴타입, 매개변수가 **모두 동일**해야!

		- 근데 왜 사용하는 것?
			▶ 부모 클래스로부터 상속을 받은 자식클래스에서
				부모 클래스의 메소드를 **오버라이딩(재정의)**했다면, 
				Parent p2 = new Child();로 선언해준 참조변수 p2에서 그 메소드를 호출했을 때,
				**자식 클래스에서 오버라이딩 된 메소드가 호출된다!**!!!
				( 부모 클래스의 메소드를 **그대로** 사용하고 싶다면,
					Parent p2 = new Parent(); 이렇게 선언해서 사용하면 되겠지? )

		< 예시 >

		public class Inheritance {
		public static void main(String[] args) {
					Parent p = new Child();
					p.hello();
					System.out.println(p.sum);  // (**에러**!!) 자식클래스의 필드 또한 호출 불가!

					Child c3 = (Child)p;         // **이렇게 선언**을 해줬다면
					System.out.println(c3.sum);  // **자식 클래스의 필드 또한 호출 가능!!**
```


​    

```java
					Child c = new Child();
					c.hello(5);	
					// 이것은 자식에서만 쓸 수 있다!
					// ( **부모로부터 물려 받은 메소드를 오버라이딩한 것이 아니기 때문**!! )
					// **부모가 자식 것을 호출할 수 있는 것은 자신의 메소드 중 오버라이딩 된 것 뿐이다!!**
					// 이 때 부모의 원래 메소드는 은닉된다.
					// 즉, 메모리 내에서 할당되지 않는다는 의미!

					Parent p2 = new Parent();	
					Child c2 = (Child)p2;
					// 이때 에러는 뜨지 않는다.
					// 하지만 컴파일 하려고 하면, 에러가 뜬다!! p2가 자식 클래스 메모리 정보를 가지고 있지 않잖아!!
					// new Parent(); 해줬기 때문!
		}
}
```


​    

```java
4. 상속의 예외
	
	● 부모 클래스에서 **private**으로 선언된 멤버들은 상속되지 않음

	● **생성자**는 자식에게 상속되지 않음
```


​    

```java
=================================================================

	public class Inheritance {
	public static void main(String[] args) {
		Parent p = new Parent();
		p.hello();
		p.hello("LONDON!");
		p.print();
		System.out.println(p.i);
		System.out.println("=====여기까지 Parent p = new Parent(); =====");
		System.out.println();
		
		Child c = new Child();
		c.hello();	// 만약 자식 클래스에서 오버라이딩 해주지 않았다고 하더라도, 부모 클래스의 메소드 호출 가능!!! 이게 상속!!
					// 그런데 오버라이딩을 했다면, 그 메소드를 호출할 수 있음!
		c.print();
		c.toString();
		System.out.println("=====여기까지 Child c = new Child(); =====");
		System.out.println();
		
		Parent p2 = new Child();
		p2.hello("Tottenham Hotspur");
		//p2.goodBye();	// 에러!! 부모가 자식을 호출하는 것 불가
		p2.print();		// 오버라이딩된 자식 메소드
		System.out.println(p2.i);	// 부모 클래스의 필드를 자식 클래스에서 다시 선언해준다고 해서 오버라이딩 아님. 메소드도 아님.
									// 그렇기 때문에 그냥 자기 클래스(부모)의 필드를 호출 ㅋ
		// 부모 레퍼런스(즉, Parent로 선언된 p2 변수)를 통해 자식을 호출할 수는 없다!!
		// 하지만 만약 오버라이딩 된 메소드가 자식 클래스에 있다면 호출 가능하다!!!!!!!!!
		System.out.println("=====여기까지 Parent p2 = new Child(); =====");
		System.out.println();
		
		Child c2 = (Child)p2;	// 컴파일 에러 나지 않음!
		c2.goodBye();   // 자식 클래스 메소드 호출 가능
		c2.hello("Arsenal");	// 부모 메소드 호출 가능!!
		System.out.println("=====여기까지 Child c2 = (Child)p2; =====");
		System.out.println();
```


​    		

```java
		Child c3 = (Child)p;	// 이렇게 선언해주면 에러가 나지는 않음.
								// 하지만 c3의 속은 자식에 대한 정보가 1도 없기에 컴파일 시 에러 발생!!!!
	}
}

===============================================================

< 생성자 (Constructor) > : 새로운 객체를 생성하기 위해서 초기화해주는 메소드

1. 생성자의 이름은 반드시 클래스명과 일치해야!! 대소문자까지도

2. 리턴 자료형을 명시하지 않는다. void 조차!
		( 리턴자료형을 뺀, 이름과 매개변수(없는 것은 기본 생성자), 내용(없는 것은 기본 생성자)이 있어야 함 )

	● 1, 2번이 일반적인 메소드와의 차이점임!

3. 객체 생성 시, 자동으로 호출

4. 클래스 내에 생성자가 하나도 없다면, 자바 컴파일러가 컴파일 시 자동으로 기본생성자를 추가!
	● 사용자가 한 개 이상의 생성자를 만들었다면, 컴파일러가 개입 X
```


​    
​    

```java
	class ABC {
						ABC() {	// 그 어떤 메소드보다도 먼저 호출됨. new를 이용하여 메모리 할당을 할 때 실행됨! 딱 한 번!
										// ABC a = new ABC();의 ABC(); 부분은 바로 생성자 호출 부분이었던 거임!
							
									// 기본 생성자 : 초기화 메소드 - 멤버 필드에 대한 초기화 담당! - 아무 것도 써있지 않을 때
									// ( 기본값 : 정수는 0, 실수는 0.0, boolean은 false,
									// 		       클래스는 NULL(아직 주소가 정의되어 있지 않다는 의미), 문자는 '\u0000')
									
									System.out.println("기본 생성자!!");
						}
						
						ABC(int su2, boolean bb, String str2) {	// 오버로딩 생성자
																										// 이거는 기본생성자가 아니라 사용자가 정의한 생성자임!
									System.out.println("오버로딩 생성자!!");
									su = su2;
									b = bb;
									str = str2;
						}
						
						/*
						void ABC() {
							// 이건  메소드임!!
						}
						*/
						
						int su;
						boolean b;
						String str;	// 얘네들은 멤버 변수(필드!). 멤버 변수(필드)는 초기값이 존재!
									// 지역 변수는 초기값이 없음!
						void print() {
									int su2;	// 지역변수
									System.out.println("프린트!");
									su2 = 3;
									System.out.println("su2 : " + su2);	// initialized 되지 않았기 때문에 바로 사용할 수 없어...
																		// 지역변수는 기본값/초기값이 없다!
									System.out.println("su : " + su);
									System.out.println("b : " + b);
									System.out.println("str : " + str);
						}
}

public class ConstructorTest {
		public static void main(String[] args) {
					ABC a = new ABC(20, true, "토튼햄");
								// 그런데 기본 생성자를 정의하지 않고 오버로딩된 생성자(위의)와 같은 생성자를 만들었다고 하자.
								// 그런데 ABC a = new ABC(); 라고 기본생성자를 호출하려 한다면?
								// 이미 사용자가 생성자를 하나 만든 상태이므로, 컴파일러는 관여하지 않고, 기본 생성자를 자동으로 만들지 않음!!
					a.print();
		}
}

=======================================================

< this : **자기클래스 참조 연산자** >

1. 메소드 내에서 사용

2. 객체 생성자 내 다른 생성자를 호출 시 사용

3. 매개변수(지역변수)와 멤버변수(필드)를 구분하기 위해 멤버 변수 앞에 this.을 붙여 사용!!

4. 현재 클래스르르 가리키는 레퍼런스 변수 (참조 변수!)
	- **보통은 생략함! (**But 필요한 경우도 있음**) :** 자기 클래스 내부에서 자기 멤버 메소드/필드 호출할 때
	- 밑에 있는 예시 중에서 '▶' 이 부분을 보면, this.를 사용하지 않으면 My 클래스 필드 name이 바뀌지 않음!!

5. 형식
		this.[필드명];
		this.[메소드명]();
		this(  );              // **같은 클래스**에 있는 **다른 생성자**를 호출!!
			▶ this();는 자기자신의 생성자를 사용하고자 할때 쓰는 것

6. super : 
		super.[필드명];
		super.[메소드명]();
		super(  );          // 부모 클래스의 생성자를 호출!!
												// 생성자는 상속의 대상이 아님!!! (예외) 그래서 이렇게 호출!
			▶ super();는 자식클래스에서 부모클래스의 생성자를 가리킬 때 쓰는 것
```


​    

```java
	class My {
			String name;
			My() {  // 기본 생성자 : 클래스 내에 생성자가 하나도 없는 상태에서 Ctrl + spacebar 누르면 기본 생성자 만들 수 있는 메뉴(?) 같은 거 나옴
					this("너무해!");
			}				
			My(String name) {	// 오버로딩 생성자
					▶this.name = name;	// 이 때, 앞의 this.name은 멤버변수(필드)이고, 뒤의 name은 지역변수.
				// name = name; 만약 this를 사용하지 않고 이렇게만 써줬다면, main에서 출력되는 것은 NULL이된다!!!
				//					(그냥 지역변수끼리 서로 대입해주구 있기 때문. 필드는 변화하지 않아!)
			}

			/*
			public My(String name) {
					super();           // 생략해도 전혀 문제는 없음 - 다만 부모 클래스의 메모리 할당하기 위함
					this.name = name;
			}
			*/
}

public class ThisTest {
			public static void main(String[] args) {
					My m = new My();
					System.out.println("name : " + m.name);
			}
}

===============================================================================

< **접근 제한(지정)자** > 4

1. private 

	● **클래스 내**에 있는 멤버끼리만 접근 가능! ( 자식 클래스도 접근 못 함! 상속 안 되기 때문 )

2. default (생략)

	● **같은 패키지 내** 클래스 간의 접근만 허용

3. protected

	● **같은 패키지 내** 클래스와 다른 패키지의 **자식 클래스**의 접근 허용

4. public

	● **모든 클래스**(같은, 다른 패키지 모두)에서 접근 허용

5. 위치 : 필드/메소드명 바로 앞에

	● [**접근 제한자**] [자료형 타입] [필드 명];
		- 4개 다
	● [**접근 제한자**] [리턴 타입] [메소드명] () { }
		- 4개 다
	● [**접근 제한자**] [class] [class명]
		- public, default(생략) 2개만 가능!!

===============================================================================

※클래스 내 클래스 선언 가능( new로 메모리 할당 )
  But, 메소드 내에 메소드 선언 불가능!

===============================================================================

< final >
1. [final] [자료형 타입] [변수명];
	● 이런 변수를 final 변수 / 종단 변수 / 마지막 변수 ( Like **constant** 변수 ) == 상수
	● 변수명을 모두 대문자로 써줌 : 일반 변수와의 식별을 위해서
		- int max = 100;            max++; --> 쌉가능!
			final int MAX = 100;      MAX++; --> 에러 발생
	● 참고 
		- public final int MAX = 100;  : 일반적으로 이게 많이 사용됨
			final public int MAX = 100;  : 둘 다 사용 가능!! final과 접근제한자 순서 상관 없음!

2. [final] [리턴형] [메소드명] (  ) {  }
	● **오버라이딩 못 하도록 막는 것**! ( **메소드 재정의를 막음** )
	● 오버로딩은 노상관인 것 같음!

3. [final] [class] [class명] { }
	● **자식 클래스를 갖지 않겠다는 것**!
		- 자식 클래스는 부모의 필드/메소드와 함께 새로운 추가적인 속성/기능을 할 수 있는
			일종의 확장 개념.
		- 그런데 이것을 하지 않겠다는 것은?
			--> **자식을 통해 부모 클래스의 내용이 변할 수 있기에 이것을 애초에 막겠다는 것! (보안)**
===============================================================================
```


```java
	< 인터페이스 > : 대표적으로 JDBC(Java - Data Base Connectivity)

1. 형식 : class와 비슷함
		
		[interface] [interface명] {
				// 필드
				//(ex.)
				public static final int su = 100; //
				// 선언된 메소드
				//(ex.)
			  public abstract void print();  //--> public, abstract가 기본적으로 사용되고, 생략되어 있음
		}
	
	● 저장은 "인터페이스명.java" ---> 컴파일 ---> "인터페이스명.class"
	● 부모와 같거나 더 넓은 접근제한자를 가지고 있어야 함

2. interface의 구성 멤버는 필드, 선언된 메소드로**만** 구성

	● public void print() {  }  --> 정의/구현된 메소드라고 함
	  public void print();      --> 바디 없는(영역 괄호 { }가 없는) **선언된 메소드**라고 함

3. 서로 다른 제품에 연결할 수 있는 공통 연결 모듈을 의미

4. 클래스에 다중 상속을 구현할 수 있음!

5. 어떻게 사용? : 클래스에 구현해서 사용!! --> Keyword : **implements
		(implements : 구현 약속 의미)**

	● [class] [class명] [implements] [interface명1] [interface명2] {

		}

		▶ 각 인터페이스가 중식, 한식, 일식 메뉴판이라고 생각하자.
		▶ 이 클래스 내에서는 모든 

(RE.. 다시 찾아보고 공부해보자)
=======================================================================

< 클래스와 인터페이스 간의 상속 문법 >

	● 클래스

	class A {}

	class B extends A { // B는 A의 확장클래스 (자식 클래스)
			
	}

----------------------------------------

	● 인터페이스

	interface A {  }

	interface B {  }

	class C implements A, B {

	}

------------------------------------------

	● 인터페이스와 클래스

	interface A {  }

	class B {  }

	class C implements A extends B {  // 이렇게 하면 **에러**가 발생!!

	}
		▶ implements를 먼저 만나게 됨. 그러면서 extends가 생략이 되었다고 판단!
		▶ class C extends Object implements A 를 먼저 만들어줌!!!

	==>
				class C extends B implements A {
			
				}
				
--------------------------------------------

	● 인터페이스 간 상속

	interface A {  }
	interface B {  }

	interface C extends A, B {
		  // implements는 구현의 약속을 의미한다.
			// extends 대신 implements를 사용하게 되면, 
	}

=======================================================================

< 추상 클래스 > : **클래스와 인터페이스의 중간 느낌!**

1. **후손 클래스를 제어할 목적으로 사용** - 방향성을 제시

2. 객체화 될 수 없는 클래스

3. 정의/구현된 메소드와 선언된 메소드로 구성

4. 스스로 객체 생성 불가 (new 사용할 수 없음!)
	 **후손 class 객체 생성( 자식은 부모다!! )해서 사용!

5.** 형식
****		
		[abstract] [class] [class명] {
				// 필드

				// 메소드
					// 정의(구현)된 메소드 { }
				[리턴 타입] [메소드명] (  ) {  }

					// 선언된 메소드();
				[abstract] [리턴 타입] [메소드명] ( );
					▶ 선언된 메소드의 경우, 반드시 abstract로 선언해야 함!!!!!! 안 쓰면 에러!!
					▶ ex.  abstract void hello();

		}

		**▶ 접근제한자 안 써줬다면, 무조건 default임!
				( 인터페이스만 특이하게 안 써주면 public이 되는 것! )**

=======================================================================

< Mission >
1. 현재 시스템의 날짜 정보를 얻기 위해 Calendar 클래스의 getInstance(int field) 메소드를 
		사용하시요

		Calendar cal = new GregrianCalendar();
		// Calendar 클래스의 자식 클래스를 활용하여 new하고, 객체 생성 가능!
```


​    
​    

```java
2. 콘솔에 입력되는 데이터 라인(줄) 단위로 받기 위해 BufferedReader 클래스에 있는
		readLine()메소드를 사용하시오.

		//Reader r = new Reader();  // 그런데 Reader은 abstract 클래스이므로 new로 객체생성 불가하고
															// 자식 클래스를 이용하여 생성할 수 있다!
		InputStream is = System.in;
		InputStreamReader isr = new InputStreamReader(is);
		BufferedReader br = new BufferedReader(Reader isr);
==> 결국 한 번에 쓰면 이거랑 똑같음
		**BufferedReader br = new BufferedReader ( new InputStreamReader ( System.in ) );**

●
●

< 입력 관련 복습 >

1. Byte 단위 입력

	import java.io.IOException;     // 입력 관련된 예외처리를 위한 클래스

	관련 클래스 내 [리턴타입] [메소드명] () throws IOException { ...
	int input = System.in.read() - 48;	// return이 그 Byte의 **아스키코드**
	System.in.read();	System.in.read();	// **버퍼를 비우기 위해**!

2. 라인 단위 입력

	import java.io.IOException;     // 입력 관련된 예외처리를 위한 클래스
	import java.io.BufferedReader;
	import java.io.InputStreamReader;		// 라인 단위 입력을 받기 위한 클래스s

	관련 클래스 내 [리턴타입] [메소드명] () throws IOException { ...
	BufferedReader br = new BufferedReader ( new InputStreamReader ( System.in ) );
	int input = br.readLine().charAt(0) - 48;

===============================================================

package com.scsa.mission1030;

import java.io.IOException;				// 입력 관련된 예외처리를 위한 클래스
//import java.io.BufferedReader;
//import java.io.InputStreamReader;		// 라인 단위 입력을 받기 위한 클래스s

class MenuOnDisplay {
	
	int no = 0;
	
	int inputNum() throws IOException {
			//BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			//int input = br.readLine().charAt(0) - 48;
			
			int input = System.in.read() - 48;	// return이 그 Byte의 아스키코드
			System.in.read();	System.in.read();	// 버퍼를 비우기 위해!
				
			return input;
	}
	
	void printMenu() {
			System.out.println("<< MENchester United >>");
			System.out.println("1. 검색    2. 증가    3. 감소    4. 종료");
			System.out.print("번호==> ");
	}
	
	void printResult(int c) {	
			switch(c)
			{
						case 1:
							System.out.println("#검색결과: " + no);
							break;
						case 2:
							System.out.println("#1증가하였습니다.");
							no++;
							break;
						case 3:
							System.out.println("#1감소하였습니다.");
							no--;
							break;
						case 4:
							System.out.println();
							System.out.println("-- END --");
							break;
						default:
							System.out.println("다시 입력해주세요!");
							break;
			}
	}
}

public class OperationProgram {
	public static void main(String[] args) throws IOException {
			int input;
			MenuOnDisplay mn = new MenuOnDisplay();
			// 이렇게 객체를 생성했기 때문에 mn에 대한 필드 no는 계속 살아서 ++, --된다!!
			
			do
			{
						mn.printMenu();
						input = mn.inputNum();
						mn.printResult(input);			
			} while(input != 4);
			
	}
}
```


​    

```java
==============================================================================

**throws는 에러를 자기를 호출하는 애한테 던지겠다/위임하겠다는 의미!!**

class Gugudan {
	// Ohoh~~
	BufferedReader br;
	
	public Gugudan() {	// 이렇게 생성자에 넣어 주는 것도 좋넹 ㅎ : 연동 시켜주는 느낌임 ㅇㅇㅇ
		br = new BufferedReader(new InputStreamReader(System.in));
	}
	
	public int inputDan() throws IOException{
		System.out.print("원하는 단? : ");
		
		//int input = br.readLine().charAt(0) - 48;
		int input = Integer.parseInt(br.readLine());
		
		return input;
    }
	
	public void printDan(int dan) {
		for(int i = 1; i <= 9; i++)
		{
			System.out.println(dan + " * " + i + " = " + (dan * i));
		}
	}
	
	public char continueDan() throws IOException {
		System.out.print("계속? (y/n) : ");

		char cont = br.readLine().charAt(0);
		
		return cont;
    }
}

public class GugudanTest {
	public static void main(String[] args) throws IOException {
		//int input;
		//char cont_input;
		Gugudan myutdan = new Gugudan();
		
		System.out.println("<<구구단>>");
		do
		{
			/*
			input = myutdan.inputDan();
			myutdan.printDan(input);
			cont_input = myutdan.continueDan();
			*/
			myutdan.printDan(myutdan.inputDan());	
			
		} while(myutdan.continueDan() != 'n');
		System.out.println("-- END --");
	}
}
```


​    

```java
==============================================================================

**package com.scsa.j1031;

public class Car {
   String carName;
   int    wheelNum;
   int    velocity;
   
   public Car(String carName, int wheelNum, int velocity) {
	   this.carName = carName;
	   this.wheelNum = wheelNum;
	   this.velocity = velocity;
   }
   
   // 근데 밑의 메소드 없더라도...? 에러 나지 않는다!!!
   // 왜냐하면 이미 Object 클래스에 정의/구현 되어 있던 메소드이기 때문이다!!!!!!!!!
   /*
   public boolean equals(Car c) {
	   if( this.carName == c.carName &&
		this.wheelNum == c.wheelNum &&
		this.velocity == c.velocity) return true;
	   return false;
   }
   
   public String toString( ) {
	 return "이 차의 이름은 " + carName + "이고, 바퀴는 " + wheelNum + "개이고, 현재 속도는 "
			 + velocity + "km/h 입니다.";  
   }
   */
```


​       

```java
   public static void main(String[] args) {
	  Car c1 = new Car("소나타", 4, 100);
	  Car c2 = new Car("소나타", 4, 100);
	  //Car c2 =c1; //주소 전달
	  System.out.println(c2.toString());
	  if(c1==c2) {
		 System.out.println("객체주소같음!!"); 
	  }else {
		 System.out.println("객체주소다름!!"); 
	  }
	  
	  if(c1.equals(c2)) {
		  System.out.println("객체내용 같음!!");
	  }else {
		  System.out.println("객체내용 다름!!");
	  }
	 /*
	  ★c1과 c2를 비교!!
	  1. (객체)주소비교
	      c1==c2
	  
	  2. 내용비교
	      c1.equals(c2)	  
	 */
   }
}**
==============================================================================
★★
< 두 객체 비교 >

Car c1 = new Car( "Sonata", 4, 100 );
Car c2 = new Car( "Benz", 4, 120 );      --> 클래스는 하나이지만, **메모리 상에 서로 다르게 할당**
												                     ( **참조변수** c1, c2는 **각각 다른 주소를 참조**! )

1. (객체의) **주소** 비교

	● 등가연산자( == ) 사용
		- 참조변수 내에 들어있는 값이 같은지 다른지 비교 ( c1, c2는 클래스가 아니라 그 클래스를 통해 
																										생성한 객체의 위치를 가리키는 주소! 참조변수! )
		- c1 == c2

		- String 타입(즉, 모든 클래스 타입)에 대해서 "=="으로 비교를 해주게 되면, 
			원치 않은 결과가 나올 수도 있음.

2. **내용** 비교 : **클래스 타입을 비교하기 위해서!!**

	● equals() 메소드 사용
		- c1.equals(c2);

	● 둘이 동일하다라는 의미 보다는,
		(뭐.. 당연히...) 클래스 참조 주소는 다르겠지만, **안의 내용이 같다**는 뜻!!

[ 20191031 ]

< Review >

1. in 상속

	● [**부**모 클래스] [참조변수] = new [**자**식 클래스] () ;
		- 이렇게 선언해도 에러 발생하지 않음!!
		- 묵시적인 형변환 포함 : ex. Parent p2 = new Child();
																Child c2 = (Child)p2;
				- 형변환해서 하는 말인데
					C에서는 int a = 3.14; 해도 에러 뜨지 않지만,
					Java에서는 int su = 3.14; 하면 에러 발생!! (double)로 캐스팅 해줘야 함!

	● 가장 중요하게 봐줘야 할 것은 new가 붙은 우측!
		- **메모리 할당**이 중요!! : 클래스 내의 멤버에 대한 메모리 적재! by using new!
		- new 우측에 명시된 클래스까지 메모리 할당!
		- 그렇기에 [**부**모 클래스] [참조변수] = new [**자**식 클래스] () ;는 가능하지만,
			[**자**식 클래스] [참조변수] = new [**부**모 클래스] () ; 은 불가능한 것!!

		- 그리고 **참조변수**는 속성변수와 다르다!
			참조변수는 **메모리 내에 적재된 부분의 주소가 담기는 것!!! 데이터가 담기는 것이 아니라

2.** 다형성 : **부모를 통한 자식 호출을 위해 "Overriding"을 사용하는 것**

3. 생성자

		● 객체 생성 직후 "단 한 번"만 호출됨 (made by using new)

4. this, super은 모두 클래스 레퍼런스의 의미와 기능을 가짐

	● 특히 this();와 super();은 각각 자기 클래스 내에 있는 다른 **생성자**를, 
																	후자는 부모 클래스의 기본**생성자**를 **호출**
			- 그런데 this();와 super();은 **반드시** 같이 사용되어서는 안되고, **홀로** 사용해야 한다.
			- 생성자 메소드 안에서 무조건 **가장 첫 번째 라인**에서 호출되어야 하므로!

	● static 영역 내에서는 사용 불가!! ex. public static void main!!!!!

5. final은 const와 동일한 기능!

6. Interface

		● 필드에 대해서는 : **public static fina**l이 기본

		● 메소드에 대해서는 : **public abstract**가 기본

		● implements를 이용하여 구현을 강제/명령 to 클래스
			( **오버라이딩 해라!!** 라는 의미 )
		● 같은 interface에 대해서는 extends를 이용하여 상속
			( implements로 하게 되면, 받는 interface 내에서 구현을 해야 하기 때문에 규칙 위배!!! )

7. 클래스 내의 필드 / 메소드를 여러 번 호출해야 한다면, 객체를 생성하는 것이 효율적이지만

	만약 단 한 번만 호출하는 경우라면, 비효율적이다. 참조변수가 메모리에 올라가니까
		( ㅋㅋ 얼마나 효율적인지 모르겠지만, 이렇게도 많이 사용한다고 함!! )

		▶ new A().hello(); 와 같은 형태로 사용 가능!!!

=================================================================================
```


​    

```java
<  >

class A {
		void method(int su) {

		}
		void hello( Parent p ) {

		}
		void goodBye ( Child c ) {

		}
}

class Test {
		public static void main(Strint[] agrs) {
				A a = new A();
				Parent p = new Parent();
				Child c = new Child();
				Parent p2 = new Child();

				a.method(300);
				int su = 500;
				a.method(su);         // 모두 가능

				a.hello(p);
				a.hello(c);   // ★자동 형변환으로 가능 (자식은 부모다!)	
				a.hello(p2);  // 타입 자체가 맞아서 이것도 가능!!

				a.goodBye(p);    // 에러가 뜸
				a.goodBye(c);    // 얘만 가능
				a.goodBye(p2);   // ★에러가 뜸 : 둘 다 타입이 다를 뿐만 아니라, Parent클래스 참조 변수는
												 //                                       Child 클래스를 채울 수 없어!!!!
				a.goodBye((Child)p2);  // ★이거는 가능!!!
															 // p2의 껍데기는 Parent이지만, **원래 속살은 Child**였기 때문!!!
		}
}
```


```java
< 클래스 **객체 생성** > : 멤버(필드, 메소드)들에 대한 **메모리 할당**

1. **동적** 메모리 할당

	● 사용하지 않는 객체에 대해서는 **가바지컬렉터가 자동으로 소멸 관리**
		( 생성자는 있지만, 소멸자는 없는 이유! )

	● Keyword : **new**

	● 참조 변수를 통해 참조! : A a = new A();    이 때, a가 바로 객체 참조 변수

2. **정적** 메모리 할당

	● 자주 사용되는 필드, 메소드에 대해 정의

	● 객체들 간의 통신에 사용 ( 공유 데이터 표현 )

	● Keyword : **static**

	● 클래스 명을 통해 참조! : [class명].[필드명];      [class명].[메소드명]();
													▶ 클래스 변수,           클래스 메소드라고 부름
														(static 변수)          (static 메소드)

		class Base {
				int su1;
				static int su2;	// 클래스 변수 ( static 변수 )라고 부름!
		}
		
		class A {
				void increment() {
						Base b = new Base();
						b.su1++;
						Base.su2++;
				}
		}
		
		class B {
				int su3;	
				void increment() {
					Base b = new Base();
						b.su1++;
						Base.su2++;
						su3 = b.su1;	// main에서 확인하기 위한 목적으로 만듦
				}
		}
		
		public class StaticTest {
				public static void main(String[] args) {
						A a = new A();
						B b = new B();
						for(int i = 0; i < 6; i++)
						{
								a.increment();
								b.increment();
						}
						
						System.out.println("Base su1 : " + b.su3);		// 이래도 답 1 나옴
						System.out.println("Base su2 : " + Base.su2);	// 이러면 12번 나옴 ㅋ
				}
		}

==========================================================================

< 내부 클래스 > : 중첩 클래스, 포함, Nested

	● 내부의 클래스가 가지고 있는 것도 내 것인데,
		**외부 클래스가 가지고 있는 것도 내 것처럼 사용할 수 있다**!

		class A {
				int su1 = 100;

				void print() {
						System.out.println(su1);     // 이것은 가능
						System.out.println(su2);     // 하지만 불가능!!
				}

				class B {
					int su2 = 300;

					void print() {
							System.out.println(su1);     // 이것도 가능
							System.out.println(su2);     // 이것도 가능
					}
				}
		}
				▶ 하지만 class A 내부에서 B b = new B();로 선언을 해준다면,
						main에서 A a = new A();라고 가정했을 때.
						a.b.print();나 a.b.su2로 접근 가능!!
						( **보통 이렇게 외부에서 한 번 A문 열어주고, 내부에서 다시 한 번 B문 열어줌** )
	
				▶ main에서 A a = new A().new B();

	● [public / final / abstract] class A {   // 외부 클래스, Outer 클래스 T

					// 필드
					// 생성자
					// 메소드
					// 1차 자원 정의

					[protected 가능 / static 가능] class B {  // 내부 클래스, inner 클래스
								// 2차 자원 정의
					}
		}

	● 종류
			▶ 정적 중첩 클래스 : static이 선언된 내부 클래스
													외부자원을 사용할 때 static이 붙는 인스턴스만 접근 가능

			▶ 비정적 중첩 클래스 : static이 선언되지 않은 내부 클래스
														일반적인 Inner 클래스

	● 저장
			▶ 컴파일(javac) --> A.class와 A$B.class가 생성
													( 이 때, A는 외부 클래스, B는 내부 클래스 )
```


​    

```java
----------------------------------------------------------

		class NestingClass {
				int no1 = 11;
				static int no2 = 13;
				
				NestedClass nested = new NestedClass();
				StaticNestedClass snc = new StaticNestedClass();
				
				void print( ) {
							System.out.println("num1 : " + nested.num1); // 객체를 생성해줘야 내부로 접근 가능!!!!!
							nested.print(); // 이렇게 함수도 호출 가능!!!
				}
				
				class NestedClass {
							int num1 = 14;
							
							void print() {
								System.out.println("num1 : " + num1);
								System.out.println("no1 : "+ no1);
								System.out.println("no2 : " + no2);
								/*
								System.out.println("num2 : " + num2); // 밑의 클래스 관련 객체가 생성되지 않았기에 접근 못 함!
								*/
							}
				}
		
				static class StaticNestedClass {
						static int num2 = 23;
						
						void print() {
							/*
							System.out.println("num1 : " + num1);	// 불가
							System.out.println("no1 : "+ no1);		// 불가!
																// static 내부 클래스가 외부 클래스에 접근할 때는
																// static이 붙은 것들만 접근 가능!!
							*/
							System.out.println("no2 : " + no2);
							System.out.println("num2 : " + num2);
						}
				}
		}
	
			public class NestedClassTest {
					public static void main(String[] args) {
								NestingClass nesting = new NestingClass();
								nesting.nested.print(); // 이렇게 외부 클래스로, 그리고 그의 내부 클래스로 타고 들어갈 수 있음!!
								// 이 방식을 더욱 많이 사용함!!!
								
								NestingClass.NestedClass nn = new NestingClass().new NestedClass();
								nn.print();
								// main의 첫 번째와 이거 같음!!
					}
			}

< 익명의 내부 클래스 : Anonymous >

		class A {
			
				void hello() {
							System.out.println("하위~");
				}
 		}

		public void print ( A a ) {
				a.hello();
		}

		위에 있는 print() 메소드를 호출!!

			▶ print();  그냥 이렇게 하면 에러가 뜸!!

			▶ A a = new A();
				 print(a);  이렇게 전달하면 됨!
				( or  print( new A() ); )
				( or  print( new A { void hello() { System.out.println("봉쥴으~"); } } ); )

     -------예시---------

				class AA {
							public void hello () {
									System.out.println("하위~");
							}
							
							public void print( AA a ) {
									a.hello();
							}
					}
					
					public class AnonymousTest {
									public static void main(String[] args) {
										AA b = new AA();
										b.hello();
										
										b.print( new AA() {
											public void hello( ) {
												System.out.println("봉쥴흐~");	// 오버라이딩!! 
											}
										});
										// 원래는
										// class My extends AA { ... 
										// 이렇게 자식 클래스를 생성하고 오버라이딩을 해야 함.
										// 이름 없는 클래스를 이렇게 사용하게 되면,
										// 추가적인 메모리 사용 없이 오버라이딩을 할 수 있음.
										// 근데 이렇게 안 해도 됨! 취향 차이라고 함 ㅎㅎ
							}
					}

=====================================================================

< **배열** >

1. 한 개의 변수 명에 여러 개의 데이터를 저장하기 위해 사용
		( 단, 모두 같은 자료형이어야 함 )

2. 데이터 관리 편리함 (index와 Loop문)

3. 배열 선언과 초기화
		▶ **자료형타입[] 배열명 = { value_lists };

				int[] arr;
				int arr[];    // 다 똑같아!!!

				int[] arr, brr;   // arr, brr은 배열(이름)
				int arr[], brr;   // arr음 배열, brr은 int형 변수**

4. 배열 객체 생성 - 마치 클래스 객체 생성처럼. 물론 클래스 배열도 가능!
		▶ **자료형타입[] 배열명 = new 자료형타임 [배열크기];

					int [] nums = new int[4];   // new int 뒤에 배열 크기 부분을 비워두면 에러!!**

		▶ **자료형타입[][] 배열명 = new 자료형타임 [행 크기][열 크기];

					int [][] nums = new int[4][3];

					int [][] nums = new int[5][];  // 가변길이열
																				// (행 사이즈는 써야 하고, 열 크기 부분 생략해도 됨)

							▷ nums[0] = new int [2];
								 nums[1] = new int [3];
								 nums[2] = new int [6];
									// 이런 식으로 행마다 다른 열 크기르르 지정해줄 수 있다!**

		▶ 초기값 : 0, 0.0, null, \u0000

		▶ **A[] su = { a, new A(), new A() };**

5. 배열의 크기(요소 개수)를 구하는 속성
		▶ 배열명.length
				(**배열은 객체다!!**)

------------------------------------------------
			public class ArrayTest {
					public static void main(String[] args) {
							int []su = {1, 2, 3, 4, 5};
							
							for(int i = 0; i < su.length; i++)
							{
									System.out.println(su[i]);
							}
							
							int [][]su2 = { {11, 22}, {33, 44, 55} };
							System.out.println("su2.length : " + su2.length);		// 행의 개수
							System.out.println("su2[0].length : " + su2[0].length);	// 행0의 열의 개수
							System.out.println("su2[1].length : " + su2[1].length); // 행1의 열의 개수
							
							for(int i = 0; i < su2.length; i++)
							{
									for(int j = 0; j < su2[i].length; j++)
									{
											System.out.print("su2[" + i + "][" + j + "] = " + su2[i][j] + "  ");
									}
									System.out.println();
							}
					}
			}

--------------------------------------------------------
import java.util.Random;

public class RandArrayTest {
	
	int []su;
	Random r = new Random();
	
	public RandArrayTest() {
		// su = { 1, 2, 3,4 ,5 };	// 에러 발생!! 이렇게 사용하면 안됨!
									// 애초에 필드에서 int []su = {1, 2, 3, 4, 5}; 로 선언해주어야 함!!
		
		su = new int[5];			// int 타입 데이터 5개 요소를 갖는 배열을 위한 동적 배열 할당
									// int []su = {0, 0, 0, 0, 0}; 으로 초기화됨!
		/*
		su = new int[] {1, 2, 3, 4, 5}; // 근데 또 이렇게는 가능!!!(1번 식으로 말고 이렇게 사용해라!!)
										// int []su = {1, 2, 3, 4, 5}; 으로 초기화됨!
										 * 
		*/
	}
	
	public void printArray() {
		for(int i = 0; i < su.length; i++)
		{
			System.out.print("su[" + i + "] = " + su[i] + "  ");
		}
	}
	public void inputArray() {
		/*  <자바의 난수> 
		 	1. java.lang.Math --> random() 메소드에서!! --> 난수 생성
		 	2. java.util.Random --> nextInt(), nextDouble() --> 난수 생성
		*/
		for(int i = 0; i < su.length; i++)
		{
			//su[i] = (int) (Math.random() * 1000);
			// Math.random()은 0.0 ~ 0.9999999999사이의 값 중 하나가 double 타입으로 리턴됨!
			
			su[i] = r.nextInt(100);	// Random 클래스 타입 참조변수가 선언이 되고 동적 메모리가 할당이 되어야 사용 가능!
									// 0 ~ 100-1까지의 int 중에서!
		}
	}
	public void sortArray() {
		int tmp;
		
		for(int i = 0; i < su.length - 1; i ++)
		{
			for(int j = i + 1; j < su.length; j++)
			{
				if(su[i] > su[j])
				{
					tmp = su[j];
					su[j] = su[i];
					su[i] = tmp;
				}
			}
		}
	}
	
	public static void main(String[] args) {
		RandArrayTest rat = new RandArrayTest();
		rat.inputArray();
		rat.sortArray();
		rat.printArray();
	}
}
----------------------------------------------------------------
import java.util.Arrays;

public class ArraysTest {
	public static void main(String[] args) {
		
		// 아래의 배열을 오름차순 정렰하시오!!	=>	java.util.Arrays의 sort() 메소드 이영!!
		int []su = {108, 13, 260, 7, 45};	
		Arrays.sort(su);	// 항상 오름차순으로!
		for(int i = 0; i < su.length; i++)
		{
			System.out.println("su[" + i + "] = " + su[i]);
		}

		System.out.println("==============================");
		
		char []ch = {'J', 'a', 'v', 'a', 'L', 'i', 'k', 'e'};
		Arrays.sort(ch);	 // 대소문자 섞여있으면, 대문자부터! (아스키 순서)
		for(int i = 0; i < ch.length; i++)
		{
			System.out.println("su[" + i + "] = " + ch[i]);
		}

		System.out.println("==============================");
		
		String []names = {"홍길동", "길라임", "김주원", "이순신", "아이유", "김유신", "Alice"};	
		Arrays.sort(names);		// 영어랑  한국어 섞여있다면, 영어부터!
		for(int i = 0; i < names.length; i++)
		{
			System.out.println("su[" + i + "] = " + names[i]);
		}
	}
}
-----------------------------------------------------------------------------
public class ArrayMission {
	public static void main(String[] args) {
		int []su = {1, 2, 3, 4, 5, 6, 7,8 ,9, 10, 564,6213,210};
		int su_len = su.length;
		
		// 4. su3이라는 배열을 만들어서 su배열의 값을 복사하시오
		// su3 = su; 이렇게 하면 참조변수가 되고, 그럼 su3의 특정 idx의 값을 변경했을 때, su까지도 변하게 되는..!!(주소 복사)
		// 그냥 복사를 하기 위해서는 참조변수를 그대로 넣어주면 위험할 수 있다!								  (값의 복사)
		int []su3 = new int[su_len];	// 같은 길이를 할당
		for(int i = 0; i < su_len; i++) su3[i] = su[i];
		for(int i = 0; i < su_len; i++) System.out.println("su3[" + i + "] = " + su3[i]);
		System.out.println("=======================");
		
		// 5. su 배열을 for문을 통해 중간에 올 때까지 양쪽을 Swap(대칭적으로)
		int tmp;
		int m = su_len / 2;
		for(int i = 0; i <= m; i++)
		{
			tmp = su[i];
			su[i] = su[su_len - 1 - i];
			su[su_len - 1 - i] = tmp;
		}
		for(int i = 0; i < su_len; i++) System.out.println("su[" + i + "] = " + su[i]);
		System.out.println("=======================");

		// 6. su 배열의 홀수 번지(idx)의 값만 출력
		for(int i = 1; i < su_len; i += 2) System.out.println("su[" + i + "] = " + su[i]);
		System.out.println("=======================");
		
		// 7.su 배열의 홀수  값만 출력
		for(int i = 1; i < su_len; i++)
		{
			if(su[i] % 2 == 1) System.out.println("su[" + i + "] = " + su[i]);
		}
		System.out.println("=======================");
	}
}

[ 20191101 ]
```
